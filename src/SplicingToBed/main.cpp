#include "ToolBase.h"
#include "NGSD.h"
#include "Exceptions.h"
#include "Helper.h"

#include <QTextStream>
#include <QFileInfo>

class ConcreteTool
		: public ToolBase
{
	Q_OBJECT

public:
	ConcreteTool(int& argc, char *argv[])
		: ToolBase(argc, argv)
	{
	}

	virtual void setup()
	{
		setDescription("Annotates junctions file generated by STAR.");
		addInfile("in", "STAR junctions output file.", false);

		addOutfile("bed", "Output BED file.", true);
		addOutfile("report", "Output annotated junctions as TSV file.", true);
		addOutfile("gene_report", "Output per-gene report as TSV file.", true);

		addInt("min_reads", "Required minimum number of reads spanning a junction.", true, 5);
		addInt("min_overhang", "Required number of overhang bases.", true, 12);

		addFlag("test", "Uses the test database instead of on the production database.");

		changeLog(2020,  6,  24, "Initial version");
	}

	//get exon rank for transcript ID and exon start/end position
	int exonRank(NGSD& db, int tx_id, int pos, QByteArray pos_type)
	{
		if (pos_type != "start" && pos_type != "end")
		{
			THROW(ArgumentException, "Invalid position type '" + pos_type + "'!");
		}

		int exon_rank = -1;

		SqlQuery query = db.getQuery();
		query.exec("SET @row_number:=0;");
		query.exec("SELECT txrows.exon_rank FROM ("
							"SELECT @row_number:=@row_number+1 AS exon_rank, gene_exon.* "
							"FROM gene_exon "
							"WHERE transcript_id=" + QString::number(tx_id) + " ORDER BY start"
						") AS txrows "
						"WHERE txrows." + pos_type + "=" + QString::number(pos));
		if (query.next())
		{
			exon_rank = query.value(0).toInt();
		}
		return exon_rank;
	}


	//find all exons with matching start/end coordinate, report gene name, transcript name and exon rank
	QMap<QByteArray, int> exonsByCoord(NGSD& db, Chromosome chr, int pos, QByteArray pos_type)
	{
		//TODO strand check
		if (pos_type != "start" && pos_type != "end")
		{
			THROW(ArgumentException, "Invalid position type '" + pos_type + "'!");
		}

		QMap<QByteArray, int> exons;

		//find exons and their rank in transcript with matching end coordinate
		SqlQuery query = db.getQuery();
		// query.prepare("SELECT gene_exon.transcript_id, gene_transcript.name, gene.symbol "
		// 				"FROM gene_exon, gene_transcript, gene "
		// 				"WHERE "
		// 				"gene_exon.transcript_id=gene_transcript.id AND "
		// 				"gene_transcript.gene_id=gene.id AND "
		// 				"gene_transcript.chromosome=:0 AND "
		// 				":1=:2"
		// 			);
		// query.bindValue(0, chr.strNormalized(false));
		// query.bindValue(1, "gene_exon." + pos_type);
		// query.bindValue(2, QString::number(pos));
		// query.exec();

		query.exec("SELECT gene_exon.transcript_id, gene_transcript.name, gene.symbol "
						"FROM gene_exon, gene_transcript, gene "
						"WHERE "
						"gene_exon.transcript_id=gene_transcript.id AND "
						"gene_transcript.gene_id=gene.id AND "
						"gene_transcript.chromosome='" + chr.strNormalized(false) + "' AND "
						"gene_exon." + pos_type + "=" + QString::number(pos)
					);
	
		while (query.next())
		{
			int tx_id = query.value(0).toInt();
			QByteArray tx_name = query.value(1).toByteArray();
			QByteArray gene_name = query.value(2).toByteArray();
			int exon_rank = exonRank(db, tx_id, pos, pos_type);

			exons.insert(gene_name + ":" + tx_name, exon_rank);
		}

		return exons;
	}

	//return all exons overlapping specified position, exons are given as gene_symbol:transcript_name:exon_start-exon_end
	QList<QByteArray> exonsByOverlap(NGSD& db, Chromosome chr, int pos, QByteArray strand="*")
	{
		QString q = "SELECT gene_exon.transcript_id, gene_exon.start, gene_exon.end, gene_transcript.name, gene.symbol "
					"FROM gene_exon, gene_transcript, gene "
					"WHERE "
						"gene_exon.start <= " + QString::number(pos) + " AND "
						" " + QString::number(pos) + " <= gene_exon.end AND "
						"gene_exon.transcript_id=gene_transcript.id AND "
						"gene_transcript.gene_id=gene.id AND "
						"gene_transcript.chromosome='" + chr.strNormalized(false) + "'";
		if (strand != "*") q.append(" AND gene_transcript.strand='" + strand + "'");

		SqlQuery query = db.getQuery();
		query.exec(q);

		QList<QByteArray> hits;
		while (query.next())
		{
			hits.append(query.value(4).toByteArray() + ":" + query.value(3).toByteArray() + ":" + query.value(1).toByteArray() + "-" + query.value(2).toByteArray());
		}
		return hits;
	}

	//make list of "k:v" strings out of map
	QList<QByteArray> mapToKvStr(QMap<QByteArray,int> map)
	{
		QList<QByteArray> out;
		QMap<QByteArray, int>::const_iterator i = map.constBegin();
		while (i != map.constEnd()) {
			out += i.key() + ":" + QByteArray::number(i.value());
			++i;
		}
		return out;
	}

	virtual void main()
	{
		//init
		NGSD db(getFlag("test"));
		int min_reads = getInt("min_reads");
		int min_overhang = getInt("min_overhang");

		//strand is encoded with 0..2
		QList<QByteArray> strand_map = {"*", "+", "-"};
		//intron motif is encoded with 0..6
		QList<QByteArray> motif_map = {"non-canonical","GT/AG","CT/AC","GC/AG","CT/GC","AT/AC","GT/AT"};

		QString bed = getOutfile("bed");
		QSharedPointer<QFile> bed_f;
		if (bed != "")
		{	
			bed_f = Helper::openFileForWriting(getOutfile("bed"), true);
			bed_f->write("#gffTags\n");
		}

		QString report = getOutfile("report");
		QSharedPointer<QFile> tsv_f;
		if (report != "")
		{
			tsv_f = Helper::openFileForWriting(getOutfile("report"), true);
			QByteArrayList column_headers = QByteArrayList() << "chr" << "intron_start" << "intron_end" << "strand" << "reads" << "motif" << "event" << "info";
			tsv_f->write("#" + column_headers.join("\t") + "\n");
		}


		QString gene_report = getOutfile("gene_report");
		QSharedPointer<QFile> gene_f;
		if (gene_report != "")
		{
			gene_f = Helper::openFileForWriting(getOutfile("gene_report"), true);
		}

		//all possible splicing events
		QByteArrayList keys = { "ALL", "MATCH", "EXON_SKIP", "KNOWN_EXONS_NO_TX",
			"R_INTRONIC", "R_EXONTRUNC", "L_INTRONIC", "L_EXONTRUNC",
			"INTRONIC_INTRONIC", "TRUNC_TRUNC", "TRUNC_INTRONIC", "INTRONIC_TRUNC" };
		//count best explanations
		QMap<QByteArray,int> stats;
		foreach (QByteArray k, keys)
		{
			stats[k] = 0;
		}
		
		QMap<QByteArray,QMap<QByteArray,int>> gene_stats;

		int line_counter = 0;
		auto fp = Helper::openFileForReading(getInfile("in"));
		while (!fp->atEnd())
		{
			if (++line_counter % 1000 == 0)
			{
				qDebug() << "line" << line_counter;
			}
			QByteArray line = fp->readLine().trimmed();
			if (line.isEmpty()) continue;

			//skip header lines
			if (line.startsWith("#")) continue;

			//split fields
			QByteArrayList parts = line.split('\t');

			//skip special chromosome
			Chromosome chr(parts[0]);
			if (!chr.isNonSpecial()) continue;

			//coverage and alignment criteria
			int unique = Helper::toInt(parts[6]);
			int multi = Helper::toInt(parts[7]);
			int overhang = Helper::toInt(parts[8]);
			if (unique < min_reads) continue;
			if (overhang < min_overhang) continue;

			//strand
			QByteArray strand = strand_map[Helper::toInt(parts[3])];

			//intron motif
			QByteArray motif = motif_map[Helper::toInt(parts[4])];

			//start and end are first and last intronic bases, use exonic bases
			int intron_start = Helper::toInt(parts[1], "start");
			int intron_end = Helper::toInt(parts[2], "end");
			int exonL_end = intron_start - 1;
			int exonR_start = intron_end + 1;

			//track all explanations
			QMultiMap<QByteArray,QByteArray> expl;

			//exact matches
			QMap<QByteArray, int> matchesL = exonsByCoord(db, chr, exonL_end, "end");
			QMap<QByteArray, int> matchesR = exonsByCoord(db, chr, exonR_start, "start");

			//same transcript found for left and right exon
			QSet<QByteArray> shared_transcripts = matchesL.keys().toSet().intersect(matchesR.keys().toSet());
			foreach (QByteArray gene_tx, shared_transcripts)
			{
				// exon L and R matches in same transcript
				int diff = std::abs(matchesL[gene_tx] - matchesR[gene_tx]);

				// gene:tx:Ea,Eb
				QByteArray desc = gene_tx + ":" + "E" + QByteArray::number(matchesL[gene_tx]) + "-E" + QByteArray::number(matchesR[gene_tx]);
				if (diff == 1)
				{
					expl.insert("MATCH", desc);
				}
				else if (diff >= 2)
				{
					expl.insert("EXON_SKIP", desc);
				}
			}

			//both exons known, but no shared transcript
			// EXON_MATCH_NO_TX
			if (shared_transcripts.isEmpty() && !matchesL.isEmpty() && !matchesR.isEmpty())
			{
				expl.insert("KNOWN_EXONS_NO_TX", mapToKvStr(matchesL).join(",") + "|" + mapToKvStr(matchesR).join(","));
			}
			else if (shared_transcripts.isEmpty())
			{
				QList<QByteArray> overlapsR = exonsByOverlap(db, chr, intron_end, strand);
				QList<QByteArray> overlapsL = exonsByOverlap(db, chr, intron_start, strand);

				if (!matchesL.isEmpty() && matchesR.isEmpty())
				{
					if (overlapsR.isEmpty())
					{
						expl.insert("R_INTRONIC", mapToKvStr(matchesL).join(",") + "|intronic");
					}
					else
					{
						expl.insert("R_EXONTRUNC", mapToKvStr(matchesL).join(",") + "|" + overlapsR.join(","));
					}
				}

				if (matchesL.isEmpty() && !matchesR.isEmpty())
				{
					if (overlapsL.isEmpty())
					{
						expl.insert("L_INTRONIC", "intronic|" + mapToKvStr(matchesR).join(","));

					}
					else
					{
						expl.insert("L_EXONTRUNC", overlapsL.join(",") + "|" + mapToKvStr(matchesR).join(","));
					}
				}

				if (matchesL.isEmpty() && matchesR.isEmpty())
				{
					if (overlapsL.isEmpty() && overlapsR.isEmpty())
					{
						expl.insert("INTRONIC_INTRONIC", "intronic|intronic");

					}
					else if (!overlapsL.isEmpty() && !overlapsR.isEmpty())
					{
						expl.insert("TRUNC_TRUNC", overlapsL.join(",") + "|" + overlapsR.join(","));

					}
					else if (!overlapsL.isEmpty() && overlapsR.isEmpty())
					{
						expl.insert("TRUNC_INTRONIC", overlapsL.join(",") + "|intronic");
					}
					else if (overlapsL.isEmpty() && !overlapsR.isEmpty())
					{
						expl.insert("INTRONIC_TRUNC", "intronic|" + overlapsR.join(","));
					}
				}
			}

			//use best explanation
			QByteArray event, info;
			if (expl.uniqueKeys().contains("MATCH"))
			{
				event = "MATCH";
				info = expl.values("MATCH").join(",");
			}
			else if (expl.uniqueKeys().contains("EXON_SKIP"))
			{
				event = "EXON_SKIP";
				info = expl.values("EXON_SKIP").join(",");
			}
			else
			{
				event = expl.constBegin().key();
				info = expl.constBegin().value();
			}

			//extract involved genes
			QSet<QByteArray> genes;
			foreach (QByteArray a, info.split('|'))
			{
				foreach (QByteArray b, a.split(','))
				{
					QList<QByteArray> c = b.split(':');
					if (c.count() >= 2)
					{
						genes.insert(c[0]);
					}
				}
			}

			QList<QByteArray> namecol = QList<QByteArray>() <<
				"Name=" + event + "%20" + QByteArray::number(unique) <<
				"Annotation=" + info <<
				"Reads=" + QByteArray::number(unique) <<
				"Motif=" + motif;
			QByteArray namecol_str = namecol.join(";");

			//tabular output line
			QByteArrayList out_line = QByteArrayList() <<
				QByteArray(chr.str()) << QByteArray::number(intron_start) << QByteArray::number(intron_end) << strand <<
				QByteArray::number(unique) << motif << genes.toList().join(",") << event << info;
			if (report != "") tsv_f->write(out_line.join("\t") + "\n");

			//BED output line
			out_line = QByteArrayList() <<
				QByteArray(chr.str()) <<
				QByteArray::number(intron_start - 1) <<
				QByteArray::number(intron_end) << 
				namecol_str <<
				QByteArray::number(unique) <<
				strand <<
				"." <<
				"." <<
				"224,2,31";
			if (bed != "") bed_f->write(out_line.join("\t") + "\n");
			
			//statistics counter
			++stats[event];
			++stats["ALL"];

			//junctions reads per gene and type
			foreach (QByteArray gene, genes)
			{
				if (!gene_stats.contains(gene))
				{
					foreach (QByteArray k, keys)
					{
						gene_stats[gene][k] = 0;
					}
				}

				gene_stats[gene][event] += unique;
				gene_stats[gene]["ALL"] += unique;
			}
		}

		//show stats
		QTextStream out(stdout);
		QMap<QByteArray, int>::const_iterator i = stats.constBegin();
		while (i != stats.constEnd())
		{
			out << i.key() << "\t" << i.value() << "\t" << QByteArray::number(1. * i.value() / stats["ALL"], 'f', 4) << endl;
			++i;
		}

		if (gene_report != "")
		{
			gene_f->write("symbol\t" + keys.join("\t") + "\tnon_match_frac\n");
			//per-gene stats
			foreach (QByteArray g, gene_stats.uniqueKeys())
			{
				QList<QByteArray> fields;
				fields.append(g);
				foreach(QByteArray k, keys)
				{
					fields.append(QByteArray::number(gene_stats[g][k]));
				}
				fields.append(QByteArray::number(1. * (gene_stats[g]["ALL"] - gene_stats[g]["MATCH"]) / gene_stats[g]["ALL"], 'f', 4));
				gene_f->write(fields.join("\t") + "\n");
			}
		}

    }
};

#include "main.moc"

int main(int argc, char *argv[])
{
	ConcreteTool tool(argc, argv);
	return tool.execute();
}
