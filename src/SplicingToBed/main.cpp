#include "ToolBase.h"
#include "NGSD.h"
#include "Exceptions.h"
#include "Helper.h"

#include <QTextStream>
#include <QFileInfo>

class ConcreteTool
		: public ToolBase
{
	Q_OBJECT

public:
	ConcreteTool(int& argc, char *argv[])
		: ToolBase(argc, argv)
	{
	}

	virtual void setup()
	{
		setDescription("Annotates junctions file generated by STAR..");
		addInfile("in", "STAR junctions output file.", false);

		addOutfile("bed", "Output BED file.", true);
		addOutfile("report", "Output gene report file.", true);

		addInt("min_reads", "Required minimum number of reads spanning a junction.", true, 5);
		addInt("min_overhang", "Required number of overhang bases.", true, 12);

		addFlag("test", "Uses the test database instead of on the production database.");

		changeLog(2020,  6,  24, "Initial version");
	}

	QByteArray geneByTranscriptId(NGSD& db, int tx_id)
	{
		QByteArray symbol = db.getValue("SELECT gene.symbol FROM gene, gene_transcript WHERE gene.id=gene_transcript.gene_id AND gene_transcript.id="+QString::number(tx_id)).toByteArray();
		return symbol;
	}

	QList<QByteArray> exonsByOverlap(NGSD& db, Chromosome chr, int pos)
	{
		QString q = "SELECT gene_exon.transcript_id, gene_exon.start, gene_exon.end, gene_transcript.name FROM gene_exon, gene_transcript WHERE gene_exon.start <= "+QString::number(pos)+" AND "+QString::number(pos)+" <= gene_exon.end AND gene_exon.transcript_id=gene_transcript.id AND gene_transcript.chromosome="+chr.strNormalized(false);
		SqlQuery query = db.getQuery();
		query.exec(q);

		QList<QByteArray> hits;
		while (query.next())
		{
			hits.append(query.value(3).toByteArray() + ":" + query.value(1).toByteArray() + "-" + query.value(2).toByteArray());
		}
		return hits;
	}

	virtual void main()
	{
		//init
		NGSD db(getFlag("test"));
		int min_reads = getInt("min_reads");
		int min_overhang = getInt("min_overhang");

		//strand is encoded with 0..2
		QList<QByteArray> strand_map = {"*", "+", "-"};
		//intron motif is encoded with 0..6
		QList<QByteArray> motif_map = {"non-canonical","GT/AG","CT/AC","GC/AG","CT/GC","AT/AC","GT/AT"};

		QString bed = getOutfile("bed");
		BedFile bed_f;
		if (bed != "")
		{
			bed_f = BedFile();
			bed_f.appendHeader("#gffTags");
		}

		QString report = getOutfile("report");
		QSharedPointer<QFile> tsv_f;
		if (report != "")
		{
			tsv_f = Helper::openFileForWriting(getOutfile("report"), true);
			QByteArrayList column_headers = QByteArrayList() << "chr" << "intron_start" << "intron_end" << "strand" << "reads" << "motif" << "genes" << "event" << "info";
			tsv_f->write("#" + column_headers.join("\t") + "\n");
		}

		QByteArrayList keys = { "ALL", "MATCH", "EXON_SKIP", "KNOWN_EXONS_NO_TX", "R_INTRONIC", "R_EXONTRUNC", "L_INTRONIC", "L_EXONTRUNC", "INTRONIC_INTRONIC", "TRUNC_TRUNC", "TRUNC_INTRONIC", "INTRONIC_TRUNC" };
		QMap<QByteArray,int> stats;
		foreach(QByteArray k, keys)
		{
			stats[k] = 0;
		}


		auto fp = Helper::openFileForReading(getInfile("in"));
		while(!fp->atEnd())
		{
			QByteArray line = fp->readLine().trimmed();
			if (line.isEmpty()) continue;

			//skip header lines
			if (line.startsWith("#")) continue;

			QByteArrayList parts = line.split('\t');

			//skip special chromosome
			Chromosome chr(parts[0]);
			if (!chr.isNonSpecial()) continue;

			//coverage and alignment criteria
			int unique(Helper::toInt(parts[6]));
			int multi(Helper::toInt(parts[7]));
			int overhang(Helper::toInt(parts[8]));
			if (unique < min_reads) continue;
			if (overhang < min_overhang) continue;

			//strand
			QByteArray strand = strand_map[Helper::toInt(parts[3])];

			//intron motif
			QByteArray motif = motif_map[Helper::toInt(parts[4])];

//			qDebug() << parts;

			//start and end are first and last intronic bases, use exonic bases
			int intron_start = Helper::toInt(parts[1], "start");
			int intron_end = Helper::toInt(parts[2], "end");
			int exonL_end = intron_start - 1;
			int exonR_start = intron_end + 1;

			QSet<QByteArray> genes;
			QList<QByteArray> expl_type;
			QList<QByteArray> expl_info;
			QList<QByteArrayList> expl_info_gene;
			QMultiMap<QByteArray,QByteArray> expl;

			//transcript IDs
			QList<int> exonL_matches, exonR_matches;
			//exon ranks within these transcripts
			QList<int> exonL_ranks, exonR_ranks;
			//transcript names
			QList<QByteArray> exonL_names, exonR_names;

			//find exons and their rank in transcript with matching end coordinate
			SqlQuery query = db.getQuery();
			query.exec("SELECT transcript_id FROM gene_exon WHERE end=" + QString::number(exonL_end));
			while(query.next())
			{
				int tx_id = query.value(0).toInt();
				exonL_matches.append(tx_id);

				Transcript tx = db.transcript(tx_id);
				exonL_names.append(tx.name());

				SqlQuery query2 = db.getQuery();
				query2.exec("SET @row_number:=0;");
				QString q = "SELECT txrows.exon_rank FROM (SELECT @row_number:=@row_number+1 AS exon_rank, gene_exon.* FROM gene_exon WHERE transcript_id="+QString::number(tx_id)+" ORDER BY start) AS txrows WHERE txrows.end="+QString::number(exonL_end);
				query2.exec(q);
				if (query2.next())
				{
					int exon_rank = query2.value(0).toInt();
					exonL_ranks.append(exon_rank);
				}
			}

			//find exons and their rank in transcript with matching start coordinate
			query.exec("SELECT transcript_id FROM gene_exon WHERE start=" + QString::number(exonR_start));
			while(query.next())
			{
				int tx_id = query.value(0).toInt();
				exonR_matches.append(tx_id);

				Transcript tx = db.transcript(tx_id);
				exonR_names.append(tx.name());

				SqlQuery query2 = db.getQuery();
				query2.exec("SET @row_number:=0;");
				QString q = "SELECT txrows.exon_rank FROM (SELECT @row_number:=@row_number+1 AS exon_rank, gene_exon.* FROM gene_exon WHERE transcript_id="+QString::number(tx_id)+" ORDER BY start) AS txrows WHERE txrows.start="+QString::number(exonR_start);
				query2.exec(q);
				if (query2.next())
				{
					int exon_rank = query2.value(0).toInt();
					exonR_ranks.append(exon_rank);
				}
			}

			//same transcript found for left and right exon
			QSet<int> shared_transcripts = exonL_matches.toSet().intersect(exonR_matches.toSet());
			foreach (int tx_id, shared_transcripts)
			{
				// exon L and R matches in same transcript
				int rank_l = exonL_ranks.at(exonL_matches.indexOf(tx_id));
				int rank_r = exonR_ranks.at(exonR_matches.indexOf(tx_id));
				int diff = std::abs(rank_l - rank_r);

				QByteArray tx_name = exonL_names.at(exonL_matches.indexOf(tx_id));


				if (diff == 1)
				{
					expl_type.append("MATCH");

					expl.insert("MATCH", tx_name);
				}
				else if (diff >= 2)
				{
					expl_type.append("EXON_SKIP");

					expl.insert("EXON_SKIP", tx_name);
				}

				expl_info.append(tx_name);
				expl_info_gene.append(QByteArrayList() << geneByTranscriptId(db, tx_id));
			}

			//both exons known, but no shared transcript
			// EXON_MATCH_NO_TX
			if (shared_transcripts.empty() && !exonL_matches.empty() && !exonR_matches.empty())
			{
				expl_type.append("KNOWN_EXONS_NO_TX");
				expl_info.append(exonL_names.join(",") + "|" + exonR_names.join(","));

				QByteArrayList genes_of_tx;
				foreach(int tx_id, exonL_matches.toSet().unite(exonR_matches.toSet()))
				{
					genes_of_tx.append(geneByTranscriptId(db, tx_id));
				}
				expl_info_gene.append(genes_of_tx);
				genes.unite(genes_of_tx.toSet());

				expl.insert("KNOWN_EXONS_NO_TX", exonL_names.join(",") + "|" + exonR_names.join(","));
			}
			else if (shared_transcripts.empty())
			{
				QList<QByteArray> exon_overlaps_right;
				QList<QByteArray> exon_overlaps_left;
				exon_overlaps_right = exonsByOverlap(db, chr, intron_end);
				exon_overlaps_left = exonsByOverlap(db, chr, intron_start);
				QSet<QByteArray> genes_right = db.genesOverlapping(chr, intron_end, intron_end).toSet();
				QSet<QByteArray> genes_left = db.genesOverlapping(chr, intron_start, intron_start).toSet();

				if (!exonL_matches.empty() && exonR_matches.empty())
				{
					genes.unite(genes_right);

					if (exon_overlaps_right.empty())
					{
						expl_type.append("R_INTRONIC");
						expl_info.append(exonL_names.join(",") + "|intronic");

						expl.insert("R_INTRONIC", exonL_names.join(",") + "|intronic");
					}
					else
					{
						expl_type.append("R_EXONTRUNC");
						expl_info.append(exonL_names.join(",") + "|" + exon_overlaps_right.join(","));

						expl.insert("R_EXONTRUNC", exonL_names.join(",") + "|" + exon_overlaps_right.join(","));
					}
				}
				if (exonL_matches.empty() && !exonR_matches.empty())
				{
					genes.unite(genes_left);

					if (exon_overlaps_left.empty())
					{
						expl_type.append("L_INTRONIC");
						expl_info.append("intronic|" + exonR_names.join(","));

						expl.insert("L_INTRONIC", "intronic|" + exonR_names.join(","));

					}
					else
					{
						expl_type.append("L_EXONTRUNC");
						expl_info.append(exon_overlaps_left.join(",") + "|" + exonR_names.join(","));

						expl.insert("L_EXONTRUNC", exon_overlaps_left.join(",") + "|" + exonR_names.join(","));

					}
				}
				if (exonL_matches.empty() && exonR_matches.empty())
				{
					genes.unite(genes_left);
					genes.unite(genes_right);

					if (exon_overlaps_left.empty() && exon_overlaps_right.empty())
					{
						expl_type.append("INTRONIC_INTRONIC");
						expl_info.append("intronic|intronic");

						expl.insert("INTRONIC_INTRONIC", "intronic|intronic");

					}
					else if (!exon_overlaps_left.empty() && !exon_overlaps_right.empty())
					{
						expl_type.append("TRUNC_TRUNC");
						expl_info.append(exon_overlaps_left.join(",") + "|" + exon_overlaps_right.join(","));

						expl.insert("TRUNC_TRUNC", exon_overlaps_left.join(",") + "|" + exon_overlaps_right.join(","));

					}
					else if (!exon_overlaps_left.empty() && exon_overlaps_right.empty())
					{
						expl_type.append("TRUNC_INTRONIC");
						expl_info.append(exon_overlaps_left.join(",") + "|intronic");

						expl.insert("TRUNC_INTRONIC", exon_overlaps_left.join(",") + "|intronic");

					}
					else if (exon_overlaps_left.empty() && !exon_overlaps_right.empty())
					{
						expl_type.append("INTRONIC_TRUNC");
						expl_info.append("intronic|" + exon_overlaps_right.join(","));

						expl.insert("INTRONIC_TRUNC", "intronic|" + exon_overlaps_right.join(","));

					}
				}
			}


//			QByteArrayList annot = QByteArrayList();
//			annot.append("Name=" + expl_type.join(",") + ";Info=" + expl_info.join(",") + ";Genes=" + genes.toList().join(",") + ";Reads=" + QByteArray::number(unique) + ";Motif=" + motif);
//			annot.append(QByteArray::number(unique));
//			annot.append(strand);
//			annot.append(QByteArray::number(intron_start - 1));
//			annot.append(QByteArray::number(intron_start - 1));
//			annot.append(color);

//			if (bed != "")
//			{
//				BedLine bl(chr, intron_start, intron_end, annot);
//				bed_f.append(bl);
//			}

			QByteArray event, info;
			GeneSet g = GeneSet();
			g.insert(genes.toList());
			QByteArray genes_j = g.toStringList().join(",").toUtf8();
			if (report != "")
			{
				if (expl.uniqueKeys().contains("MATCH"))
				{
					event = "MATCH";
					info = expl.values("MATCH").join(",");
				}
				else if (expl.uniqueKeys().contains("EXON_SKIP"))
				{
					event = "EXON_SKIP";
					info = expl.values("EXON_SKIP").join(",");
				}
				else
				{
					Q_ASSERT(expl.size() == 1);
					QMap<QByteArray, QByteArray>::const_iterator i = expl.constBegin();
					event = i.key();
					info = i.value();
				}


				QByteArrayList out_line = QByteArrayList() << QByteArray(chr.str()) << QByteArray::number(intron_start) << QByteArray::number(intron_end) << strand << QByteArray::number(unique) << motif << genes_j << event << info;
				tsv_f->write(out_line.join("\t") + "\n");
				stats[event]++;
			}
		}

		//write BED
		if (bed != "")
		{
			bed_f.store(bed);
		}

    }
};

#include "main.moc"

int main(int argc, char *argv[])
{
	ConcreteTool tool(argc, argv);
	return tool.execute();
}
